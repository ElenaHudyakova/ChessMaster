This file was created by PyCharm 2.0.2 for binding GitHub repository
This file was modified by PyCharm 2.0.2 for binding GitHub repository


class PawnMotionStrategy(MotionStrategy):

    def _get_direction(self, color):
        if color == WHITE:
            return 1
        else:
            return -1

    def _is_first_move(self, color, from_point):
        if (from_point.rank == 2 and color == WHITE) or (from_point.rank == 7 and color == BLACK):
            return True
        else:
            return False

    def _can_move(self, board_state, from_point, to_point):
        direction = self._get_direction(board_state.active_color)
        if self._is_first_move(board_state.active_color, from_point):
            if to_point.file == from_point.file and (to_point.rank == from_point.rank + direction or (to_point.rank == from_point.rank + direction*2\
            and board_state[(from_point.file, from_point.rank + direction)] is None)):
                return True
            else:
                return False
        else:
            if to_point.file == from_point.file and to_point.rank == from_point.rank + direction:
                return True
            else:
                return False

    def _can_capture(self, board_state, from_point, to_point):
        direction = self._get_direction(board_state.active_color)
        if math.fabs(from_point.file-to_point.file) == 1 and from_point.rank + direction == to_point.rank:
            return True
        else:
            return False

    def is_en_passant_possible(self, board_state, from_point, to_point):
        if (board_state.en_passant_point is None):
            return False
        return (to_point == board_state.en_passant_point) and \
                   not (board_state[(to_point.file, from_point.rank)] is None) and\
               board_state[(to_point.file, from_point.rank)].color != board_state[(from_point.file, from_point.rank)].color


    def is_move_possible(self, board_state, from_point, to_point):
        if board_state[(to_point.file,to_point.rank)] is None\
                and  self._can_move(board_state, from_point, to_point):
            return True
        else:
            return self.is_en_passant_possible(board_state, from_point, to_point)

    def is_capture_possible(self, board_state, from_point, to_point):
        if not (board_state[(to_point.file, to_point.rank)] is None)\
           and board_state[(to_point.file, to_point.rank)].color != board_state[(from_point.file, from_point.rank)].color\
        and self._can_capture(board_state, from_point, to_point):
            return True
        else:
            return self.is_en_passant_possible(board_state, from_point, to_point)

    def make_en_passant(self, board_state, from_point, to_point):
        board_state[from_point].point = to_point
        board_state.pieces.remove(board_state[(to_point.file, from_point.rank)])

    def make_move(self, board_state, from_point, to_point):
        direction = self._get_direction(board_state.active_color)
        if to_point.rank == from_point.rank + direction*2:
            board_state.en_passant_point = Point(from_point.file, from_point.rank + direction)
        else:
            board_state.en_passant_point = None

        if not (board_state.en_passant_point is None):
            if board_state.en_passant_point == to_point:
                self.make_en_passant(board_state, from_point, to_point)
        else:
            board_state[from_point].point = to_point

    def make_capture(self, board_state, from_point, to_point):
        if not (board_state.en_passant_point is None):
            if board_state.en_passant_point == to_point:
                self.make_en_passant(board_state, from_point, to_point)
        else:
            board_state.pieces.remove(board_state[to_point])
            board_state[from_point].point = to_point
            board_state.en_passant_point = None